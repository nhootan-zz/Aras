/*********************************************************************
 * Author: Hootan Nakhost (Nakhost@ualberta.ca)
 * (C) Copyright 2009-2013 Hootan Nakhost
 *
 * This file is part of Aras.
 * This is a modified version of search_space.cc in FD's code base.
 * Aras is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 3
 * of the license, or (at your option) any later version.
 *
 * Aras is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 *********************************************************************/

#include "neighborhood_graph.h"
#include "../state.h"
#include "../operator.h"
#include <algorithm>
#include <climits> 
#include <cassert>
#include <ext/hash_map>
#include <set>

using namespace std;
using namespace __gnu_cxx;

class NodeInfo {
	friend class Node;
	friend class NeigborhoodGraph;

	enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};
	enum ExpandStatus {NOT_EXPANDED = 0, EXPANDED = 1};
	 
	unsigned int status : 2;
	unsigned int expand_status : 1;
	unsigned int reg_expand_status : 1;
	int h : 28;
	int g : 32;
	
	set<pair<state_var_t *, const Operator *> > parents;

public:
	NodeInfo() :
		status(NEW), expand_status(NOT_EXPANDED), h(-1), g(-1){
	}

};

class StateProxy {
	// This class is basically a pointer that can be reassigned even
	// though it is const. This is needed for the hash table below,
	// where a node may first be inserted with a pointer to a
	// temporary object as the key, which will then later be replaced
	// with a pointer to a heap-allocated object generated by
	// make_permanent below.
	// Despite the const-ness, mutating the key of a hash_map in place
	// is fine as long as the mutation does not affect the hash value
	// (which this one does not, as it only changes the address of the
	// state, whereas the contents of the state are used for hashing).

	// Update: This was changed from a State* to an state_var_t*
	//         that points "inside" the state to shave off some memory.
public:
	mutable state_var_t *state_data;
	mutable bool borrowed_buffer;
	~StateProxy() {
		if(! borrowed_buffer)
			delete[] state_data;
	}
	StateProxy() {
		state_data = 0;
		borrowed_buffer = false;
	}

	StateProxy(state_var_t *state_data_) {
		state_data = state_data_;
		borrowed_buffer = true;
	}

	explicit StateProxy(const State *state) {
		state_data = const_cast<state_var_t *>(state->get_buffer());
		borrowed_buffer = true;
	}

	const StateProxy &operator=(const StateProxy &other) const {
		borrowed_buffer = true;
		state_data = other.state_data;
		return *this;
	}
	bool operator==(const StateProxy &other) const {
		return State(state_data) == State(other.state_data);
	}
	void make_permanent() const {
		borrowed_buffer = false;
		state_var_t *new_buffer = new state_var_t[g_variable_domain.size()];
		for (int i = 0; i < g_variable_domain.size(); i++)
			new_buffer[i] = state_data[i];
		state_data = new_buffer;
	}
};

namespace __gnu_cxx {
template<> struct hash<StateProxy> {
	size_t operator()(const StateProxy &state_proxy) const {
		return State(state_proxy.state_data).hash();
	}
};
}

Node::Node(state_var_t *state_buffer_, NodeInfo &info_, size_t* parents_num_byte_) :
	state_buffer(state_buffer_), info(info_), parents_num(parents_num_byte_) {
}

State Node::get_state() const {
	return State(state_buffer);
}

bool Node::is_goal() const {
	State s = State(state_buffer);
	for (int i = 0; i < g_goal.size(); i++)
		if (s[g_goal[i].first] != g_goal[i].second)
			return false;
	return true;
}

bool Node::is_expanded() const {
	return info.expand_status == NodeInfo::EXPANDED;
}

bool Node::is_reg_expanded() const {
	return info.reg_expand_status == NodeInfo::EXPANDED;
}

bool Node::is_new() const {
	return info.status == NodeInfo::NEW;
}

bool Node::is_open() const {
	return info.status == NodeInfo::OPEN;
}

bool Node::is_closed() const {
	return info.status == NodeInfo::CLOSED;
}

bool Node::is_dead_end() const {
	return info.status == NodeInfo::DEAD_END;
}

int Node::get_f() const {
	return info.g + info.h;
}

int Node::get_g() const {
	return info.g;
}

int Node::get_h() const {
	return info.h;
}

int Node::get_parent_num() const {
	return info.parents.size();
}

const vector<pair<state_var_t *, const Operator *> > Node::get_parents(){
	vector<pair<state_var_t *, const Operator *> > result;
	result.resize(info.parents.size());
	copy(info.parents.begin(), info.parents.end(), result.begin());
	return result;
}

void Node::open_initial(int h) {
	assert(info.status == NodeInfo::NEW);
	info.status = NodeInfo::OPEN;
	info.expand_status = NodeInfo::NOT_EXPANDED;
	info.g = 0;
	info.h = h;
}

void Node::add_parent(const Node &parent_Node, const Operator *parent_op) {
	(*parents_num) -= info.parents.size();
	//cout << "parents_num: " << (*parents_num) << " parents.size(): " << info.parents.size() << endl;
	info.parents.insert(make_pair(parent_Node.state_buffer, parent_op));
	(*parents_num) += info.parents.size();
	//cout << "parents_num: " << (*parents_num) << " parents.size(): " << info.parents.size() << endl;
}

void Node::update_and_open(int h, int g, int op_cost) {
	assert(info.status == NodeInfo::NEW);
	info.status = NodeInfo::OPEN;
	info.g = g + op_cost;
	info.h = h;
}

void Node::update_and_reopen(int g, int op_cost) {
	assert(info.status == NodeInfo::OPEN);
	info.status = NodeInfo::OPEN;
	info.g = g + op_cost;
}

void Node::lazy_open(int h, const Node &parent_Node, const Operator *parent_op) {
	assert(info.status == NodeInfo::NEW);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + parent_op->get_cost();
	info.h = h;
}

void Node::lazy_reopen(const Node &parent_Node, const Operator *parent_op) {
	assert(info.status == NodeInfo::OPEN);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + parent_op->get_cost();
}

void Node::make_permanent() {
	if (info.status == NodeInfo::CLOSED)
		info.expand_status = NodeInfo::EXPANDED;
	info.status = NodeInfo::NEW;
}

void Node::make_reg_permanent() {
	if (info.status == NodeInfo::CLOSED)
		info.reg_expand_status = NodeInfo::EXPANDED;
	info.status = NodeInfo::NEW;
}

void Node::open(int h, const Node &parent_Node, const Operator *parent_op) {
	// assert(info.status == SearchNodeInfo::NEW);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + parent_op->get_cost();
	info.h = h;
	(*parents_num) -= info.parents.size();
	info.parents.clear();
	info.parents.insert(make_pair(parent_Node.state_buffer, parent_op));
	(*parents_num) += info.parents.size();
}

void Node::reopen(const Node &parent_Node, const Operator *parent_op) {
	// Must never reopen closed Nodes with consistent heuristics.
	// assert(info.status == SearchNodeInfo::OPEN);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + parent_op->get_cost();
	(*parents_num) -= info.parents.size();
	info.parents.clear();
	info.parents.insert(make_pair(parent_Node.state_buffer, parent_op));
	(*parents_num) += info.parents.size();
}

void Node::open(int h, const Node &parent_Node, const Operator *parent_op, int op_cost) {
	// assert(info.status == SearchNodeInfo::NEW);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + op_cost;
	info.h = h;
	(*parents_num) -= info.parents.size();
	info.parents.clear();
	info.parents.insert(make_pair(parent_Node.state_buffer, parent_op));
	(*parents_num) += info.parents.size();
}

void Node::reopen(const Node &parent_Node, const Operator *parent_op, int op_cost) {
	// Must never reopen closed Nodes with consistent heuristics.
	// assert(info.status == SearchNodeInfo::OPEN);
	info.status = NodeInfo::OPEN;
	info.g = parent_Node.info.g + op_cost;
	(*parents_num) -= info.parents.size();
	info.parents.clear();
	info.parents.insert(make_pair(parent_Node.state_buffer, parent_op));
	(*parents_num) += info.parents.size();
}



void Node::close() {

	assert(info.status == NodeInfo::OPEN);
	info.status = NodeInfo::CLOSED;
}

void Node::mark_as_dead_end() {
	assert(info.status == NodeInfo::NEW);
	info.status = NodeInfo::DEAD_END;
}

void Node::dump() {
	cout << state_buffer << ": ";
	State(state_buffer).dump();
	cout << info.parents.size() << endl;
	if (info.parents.size() > 0) {
		cout << " created by " << info.parents.begin()->second->get_name() << " from " << info.parents.begin()->first << endl;
	}
}

class NeigborhoodGraph::HashTable : public __gnu_cxx::hash_map<StateProxy, NodeInfo> {
// This is more like a typedef really, but we need a proper class
// so that we can hide the information in the header file by using
// a forward declaration. This is also the reason why the hash
// table is allocated dynamically in the constructor.
};

NeigborhoodGraph::NeigborhoodGraph() {
	nodes = new HashTable;
	keep_shallow_copy = false;
	parents_num = 0;
}

NeigborhoodGraph::~NeigborhoodGraph() {
	delete nodes;
}

int NeigborhoodGraph::size() const {
	return nodes->size();
}
size_t NeigborhoodGraph::memory_usage() const{
	size_t num_nodes = nodes->size();
	size_t size_state = sizeof(State) + sizeof(state_var_t) * g_variable_domain.size();
	size_t parents_memory = parents_num * (sizeof(pair<state_var_t *, const Operator *>) + sizeof(int) + 3*
	sizeof(int*));
	size_t hash_memory = ((nodes->bucket_count() + num_nodes) * sizeof(int*) + sizeof(pair<StateProxy,
	NodeInfo>) * num_nodes);
	size_t state_memory = (num_nodes * (size_state));
	if(!keep_shallow_copy)
	    return (parents_memory + state_memory + hash_memory); 
        else return (parents_memory + hash_memory);
}



Node NeigborhoodGraph::get_node(const State &state) {
	static NodeInfo default_info;
	pair<HashTable::iterator, bool> result = nodes->insert(make_pair(StateProxy(&state), default_info));
	if (result.second && !keep_shallow_copy) {
		// This is a new entry: Must give the state permanent lifetime.
		result.first->first.make_permanent();
	}
	HashTable::iterator iter = result.first;
	return Node(iter->first.state_data, iter->second, &parents_num);
}


void NeigborhoodGraph::trace_path(const State &goal_state, vector<const Operator *> &path) const {
	StateProxy current_state(&goal_state);
	assert(path.empty());
	int count = 0;
	for (;;) {
		count ++;
		HashTable::const_iterator iter = nodes->find(current_state);
		assert(iter != nodes->end());
		const NodeInfo &info = iter->second;
		if(info.parents.size() == 0)
			break;
		
		const Operator *op = info.parents.begin()->second;
		path.push_back(op);
		current_state = StateProxy(const_cast<state_var_t *>(info.parents.begin()->first));
	}
}

void NeigborhoodGraph::dump() {
	int i = 0;
	for (HashTable::iterator iter = nodes->begin(); iter != nodes->end(); iter++) {
		cout << "#" << i++ << " (" << iter->first.state_data << "): ";
		State(iter->first.state_data).dump();
		if (iter->second.parents.size() > 0) {
			cout << " created by " << iter->second.parents.begin()->second->get_name() << " from "
					<< iter->second.parents.begin()->first << endl;
		} else {
			cout << "has no parent" << endl;
		}
	}
}

void NeigborhoodGraph::statistics() const {
	cout << "search space hash size: " << nodes->size() << endl;
	cout << "search space hash bucket count: " << nodes->bucket_count() << endl;
}
